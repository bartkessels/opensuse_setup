(function() {
  var Emitter, Marker, MarkerIndex, MarkerLayer, Point, Range, SerializationVersion, clone, filterSet, intersectSet;

  clone = require("underscore-plus").clone;

  Emitter = require('event-kit').Emitter;

  Point = require("./point");

  Range = require("./range");

  Marker = require("./marker");

  MarkerIndex = require("marker-index");

  intersectSet = require("./set-helpers").intersectSet;

  SerializationVersion = 2;

  module.exports = MarkerLayer = (function() {
    MarkerLayer.deserialize = function(delegate, state) {
      var store;
      store = new MarkerLayer(delegate, 0);
      store.deserialize(state);
      return store;
    };

    MarkerLayer.serializeSnapshot = function(snapshot) {
      var layerId, markerId, markerSnapshot, markerSnapshots, result;
      result = {};
      for (layerId in snapshot) {
        markerSnapshots = snapshot[layerId];
        result[layerId] = {};
        for (markerId in markerSnapshots) {
          markerSnapshot = markerSnapshots[markerId];
          result[layerId][markerId] = clone(markerSnapshot);
          result[layerId][markerId].range = markerSnapshot.range.serialize();
        }
      }
      return result;
    };

    MarkerLayer.deserializeSnapshot = function(snapshot) {
      var layerId, markerId, markerSnapshot, markerSnapshots, result;
      result = {};
      for (layerId in snapshot) {
        markerSnapshots = snapshot[layerId];
        result[layerId] = {};
        for (markerId in markerSnapshots) {
          markerSnapshot = markerSnapshots[markerId];
          result[layerId][markerId] = clone(markerSnapshot);
          result[layerId][markerId].range = Range.deserialize(markerSnapshot.range);
        }
      }
      return result;
    };


    /*
    Section: Lifecycle
     */

    function MarkerLayer(delegate, id, options) {
      var _ref;
      this.delegate = delegate;
      this.id = id;
      this.maintainHistory = (_ref = options != null ? options.maintainHistory : void 0) != null ? _ref : false;
      this.emitter = new Emitter;
      this.index = new MarkerIndex;
      this.markersById = {};
      this.markersIdsWithChangeSubscriptions = new Set;
      this.destroyed = false;
      this.emitCreateMarkerEvents = false;
    }

    MarkerLayer.prototype.copy = function() {
      var copy, marker, markerId, snapshot, _ref;
      copy = this.delegate.addMarkerLayer({
        maintainHistory: this.maintainHistory
      });
      _ref = this.markersById;
      for (markerId in _ref) {
        marker = _ref[markerId];
        snapshot = marker.getSnapshot(null);
        copy.createMarker(marker.getRange(), marker.getSnapshot());
      }
      return copy;
    };

    MarkerLayer.prototype.destroy = function() {
      this.destroyed = true;
      this.delegate.markerLayerDestroyed(this);
      this.emitter.emit('did-destroy');
      return this.emitter.dispose();
    };

    MarkerLayer.prototype.isDestroyed = function() {
      return this.destroyed;
    };

    MarkerLayer.prototype.isAlive = function() {
      return !this.destroyed;
    };


    /*
    Section: Querying
     */

    MarkerLayer.prototype.getMarker = function(id) {
      return this.markersById[id];
    };

    MarkerLayer.prototype.getMarkers = function() {
      var id, marker, _ref, _results;
      _ref = this.markersById;
      _results = [];
      for (id in _ref) {
        marker = _ref[id];
        _results.push(marker);
      }
      return _results;
    };

    MarkerLayer.prototype.getMarkerCount = function() {
      return Object.keys(this.markersById).length;
    };

    MarkerLayer.prototype.findMarkers = function(params) {
      var end, key, markerIds, position, result, start, value, _i, _len, _ref, _ref1, _ref2, _ref3;
      markerIds = null;
      _ref = Object.keys(params);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        value = params[key];
        switch (key) {
          case 'startPosition':
            markerIds = filterSet(markerIds, this.index.findStartingAt(Point.fromObject(value)));
            break;
          case 'endPosition':
            markerIds = filterSet(markerIds, this.index.findEndingAt(Point.fromObject(value)));
            break;
          case 'containsPoint':
          case 'containsPosition':
            position = Point.fromObject(value);
            markerIds = filterSet(markerIds, this.index.findContaining(position, position));
            break;
          case 'containsRange':
            _ref1 = Range.fromObject(value), start = _ref1.start, end = _ref1.end;
            markerIds = filterSet(markerIds, this.index.findContaining(start, end));
            break;
          case 'intersectsRange':
            _ref2 = Range.fromObject(value), start = _ref2.start, end = _ref2.end;
            markerIds = filterSet(markerIds, this.index.findIntersecting(start, end));
            break;
          case 'startRow':
            markerIds = filterSet(markerIds, this.index.findStartingIn(Point(value, 0), Point(value, Infinity)));
            break;
          case 'endRow':
            markerIds = filterSet(markerIds, this.index.findEndingIn(Point(value, 0), Point(value, Infinity)));
            break;
          case 'intersectsRow':
            markerIds = filterSet(markerIds, this.index.findIntersecting(Point(value, 0), Point(value, Infinity)));
            break;
          case 'intersectsRowRange':
            markerIds = filterSet(markerIds, this.index.findIntersecting(Point(value[0], 0), Point(value[1], Infinity)));
            break;
          case 'containedInRange':
            _ref3 = Range.fromObject(value), start = _ref3.start, end = _ref3.end;
            markerIds = filterSet(markerIds, this.index.findContainedIn(start, end));
            break;
          default:
            continue;
        }
        delete params[key];
      }
      if (markerIds == null) {
        markerIds = new Set(Object.keys(this.markersById));
      }
      result = [];
      markerIds.forEach((function(_this) {
        return function(id) {
          var marker;
          marker = _this.markersById[id];
          if (marker.matchesParams(params)) {
            return result.push(marker);
          }
        };
      })(this));
      return result.sort(function(a, b) {
        return a.compare(b);
      });
    };


    /*
    Section: Marker creation
     */

    MarkerLayer.prototype.markRange = function(range, options) {
      if (options == null) {
        options = {};
      }
      return this.createMarker(this.delegate.clipRange(range), Marker.extractParams(options));
    };

    MarkerLayer.prototype.markPosition = function(position, options) {
      if (options == null) {
        options = {};
      }
      if (options.tailed == null) {
        options.tailed = false;
      }
      position = this.delegate.clipPosition(position);
      return this.markRange(new Range(position, position), options);
    };


    /*
    Section: Event subscription
     */

    MarkerLayer.prototype.onDidUpdate = function(callback) {
      return this.emitter.on('did-update', callback);
    };

    MarkerLayer.prototype.onDidCreateMarker = function(callback) {
      this.emitCreateMarkerEvents = true;
      return this.emitter.on('did-create-marker', callback);
    };

    MarkerLayer.prototype.onDidDestroy = function(callback) {
      return this.emitter.on('did-destroy', callback);
    };


    /*
    Section: Private - TextBuffer interface
     */

    MarkerLayer.prototype.splice = function(start, oldExtent, newExtent) {
      var invalidated;
      invalidated = this.index.splice(start, oldExtent, newExtent);
      invalidated.touch.forEach((function(_this) {
        return function(id) {
          var marker, _ref;
          marker = _this.markersById[id];
          if ((_ref = invalidated[marker.getInvalidationStrategy()]) != null ? _ref.has(id) : void 0) {
            return marker.valid = false;
          }
        };
      })(this));
      return this.scheduleUpdateEvent();
    };

    MarkerLayer.prototype.restoreFromSnapshot = function(snapshots) {
      var existingMarkerIds, id, marker, newMarker, snapshot, snapshotIds, _i, _j, _len, _len1;
      if (snapshots == null) {
        return;
      }
      snapshotIds = Object.keys(snapshots);
      existingMarkerIds = Object.keys(this.markersById);
      for (_i = 0, _len = snapshotIds.length; _i < _len; _i++) {
        id = snapshotIds[_i];
        snapshot = snapshots[id];
        if (marker = this.markersById[id]) {
          marker.update(marker.getRange(), snapshot, true);
        } else {
          newMarker = this.createMarker(snapshot.range, snapshot);
        }
      }
      for (_j = 0, _len1 = existingMarkerIds.length; _j < _len1; _j++) {
        id = existingMarkerIds[_j];
        if ((marker = this.markersById[id]) && (snapshots[id] == null)) {
          marker.destroy();
        }
      }
      return this.delegate.markersUpdated(this);
    };

    MarkerLayer.prototype.createSnapshot = function() {
      var id, marker, ranges, result, _i, _len, _ref;
      result = {};
      ranges = this.index.dump();
      _ref = Object.keys(this.markersById);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        marker = this.markersById[id];
        result[id] = marker.getSnapshot(Range.fromObject(ranges[id]), false);
      }
      return result;
    };

    MarkerLayer.prototype.emitChangeEvents = function(snapshot) {
      this.markersIdsWithChangeSubscriptions.forEach((function(_this) {
        return function(id) {
          var marker, _ref;
          if (marker = _this.markersById[id]) {
            return marker.emitChangeEvent(snapshot != null ? (_ref = snapshot[id]) != null ? _ref.range : void 0 : void 0, true, false);
          }
        };
      })(this));
      return this.delegate.markersUpdated(this);
    };

    MarkerLayer.prototype.serialize = function() {
      var id, marker, markersById, ranges, _i, _len, _ref;
      ranges = this.index.dump();
      markersById = {};
      _ref = Object.keys(this.markersById);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        marker = this.markersById[id];
        if (marker.persistent) {
          markersById[id] = marker.getSnapshot(Range.fromObject(ranges[id]), false);
        }
      }
      return {
        id: this.id,
        maintainHistory: this.maintainHistory,
        markersById: markersById,
        version: SerializationVersion
      };
    };

    MarkerLayer.prototype.deserialize = function(state) {
      var id, markerState, range, _ref;
      if (state.version !== SerializationVersion) {
        return;
      }
      this.id = state.id;
      this.maintainHistory = state.maintainHistory;
      _ref = state.markersById;
      for (id in _ref) {
        markerState = _ref[id];
        range = Range.fromObject(markerState.range);
        delete markerState.range;
        this.addMarker(id, range, markerState);
      }
    };


    /*
    Section: Private - Marker interface
     */

    MarkerLayer.prototype.markerUpdated = function() {
      this.delegate.markersUpdated(this);
      return this.scheduleUpdateEvent();
    };

    MarkerLayer.prototype.destroyMarker = function(id) {
      if (this.markersById.hasOwnProperty(id)) {
        delete this.markersById[id];
        this.markersIdsWithChangeSubscriptions["delete"](id);
        this.index["delete"](id);
        this.delegate.markersUpdated(this);
        return this.scheduleUpdateEvent();
      }
    };

    MarkerLayer.prototype.getMarkerRange = function(id) {
      return Range.fromObject(this.index.getRange(id));
    };

    MarkerLayer.prototype.getMarkerStartPosition = function(id) {
      return Point.fromObject(this.index.getStart(id));
    };

    MarkerLayer.prototype.getMarkerEndPosition = function(id) {
      return Point.fromObject(this.index.getEnd(id));
    };

    MarkerLayer.prototype.setMarkerRange = function(id, range) {
      var end, start, _ref;
      _ref = Range.fromObject(range), start = _ref.start, end = _ref.end;
      start = this.delegate.clipPosition(start);
      end = this.delegate.clipPosition(end);
      this.index["delete"](id);
      return this.index.insert(id, start, end);
    };

    MarkerLayer.prototype.setMarkerHasTail = function(id, hasTail) {
      return this.index.setExclusive(id, !hasTail);
    };

    MarkerLayer.prototype.createMarker = function(range, params) {
      var id, marker;
      id = this.delegate.getNextMarkerId();
      marker = this.addMarker(id, range, params);
      this.delegate.markerCreated(this, marker);
      this.delegate.markersUpdated(this);
      this.scheduleUpdateEvent();
      if (this.emitCreateMarkerEvents) {
        this.emitter.emit('did-create-marker', marker);
      }
      return marker;
    };


    /*
    Section: Internal
     */

    MarkerLayer.prototype.addMarker = function(id, range, params) {
      var marker;
      Point.assertValid(range.start);
      Point.assertValid(range.end);
      marker = new Marker(id, this, range, params);
      this.markersById[id] = marker;
      this.index.insert(id, range.start, range.end);
      if (marker.getInvalidationStrategy() === 'inside') {
        this.index.setExclusive(id, true);
      }
      return marker;
    };

    MarkerLayer.prototype.scheduleUpdateEvent = function() {
      if (!this.didUpdateEventScheduled) {
        this.didUpdateEventScheduled = true;
        return process.nextTick((function(_this) {
          return function() {
            _this.didUpdateEventScheduled = false;
            return _this.emitter.emit('did-update');
          };
        })(this));
      }
    };

    return MarkerLayer;

  })();

  filterSet = function(set1, set2) {
    if (set1) {
      intersectSet(set1, set2);
      return set1;
    } else {
      return set2;
    }
  };

}).call(this);
